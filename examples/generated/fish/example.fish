# This script was generated by crazy-complete.
# crazy-complete: A tool that creates robust and reliable autocompletion scripts for Bash, Fish and Zsh.
# For more information, visit: https://github.com/crazy-complete/crazy-complete

function _example__list
  set -l duplicates false

  if test $argv[1] = '-d'
    set duplicates true
    set -e argv[1]
  end

  set -l separator $argv[1]
  set -l func $argv[2]
  set -l comp (_example__get_completing_arg)

  if test -z "$comp"
    eval $func
    return
  end

  set -l i
  set -l value
  set -l values
  set -l descriptions

  set -g __fish_stripprefix "^.*"(string escape --style=regex -- $separator)

  for value in (eval $func)
    set -l split (string split -- \t $value)
    set -a values $split[1]
    set -a descriptions "$split[2]"
  end

  set -e __fish_stripprefix

  set -l having_values (string split -- $separator $comp)
  set -l remaining_values_idxs

  if $duplicates
    set remaining_values_idxs (command seq 1 (count $values))
  else
    set i 1
    for value in $values
      if not contains -- $value $having_values
        set -a remaining_values_idxs $i
      end

      set i (math $i + 1)
    end
  end

  switch $comp
    case "*$separator"
      for i in $remaining_values_idxs
        printf '%s%s\t%s\n' $comp $values[$i] "$descriptions[$i]"
      end
    case "*$separator*"
      set comp (string split -r -m 1 -- $separator $comp)[1]

      for i in $remaining_values_idxs
        printf '%s%s%s\t%s\n' "$comp" $separator $values[$i] "$descriptions[$i]"
      end
    case '*'
      for i in $remaining_values_idxs
        printf '%s\t%s\n' $values[$i] "$descriptions[$i]"
      end
  end
end

function _example__get_completing_arg
  set -l arg (commandline -ct | string unescape)

  switch $arg
    case '--*=' '--*=*'
      set arg (string replace -r -- '^-[^=]*=' '' $arg)
    case '-*'
      set -l prog (commandline -po)[1]
      set -l progdef (complete -c $prog)

      set -l full_opt (string match -r -- '^-[a-zA-Z0-9]+=' $arg)
      set -l opt (string sub -s 2 -e -1 -- $full_opt)
      set -l optdefs (string match -re -- " -(o|-old-option) $opt( |\$)" $progdef)
      set -l optdefs (string match -re -- " -(x|r|a|-(exclusive|require-parameter|arguments))( |\$)" $optdefs)

      if test (count $optdefs) -gt 0
        set arg (string replace -m 1 -- $full_opt '' $arg)
      else
        set -l i 2

        while test $i -lt (string length -- $arg)
          set -l opt (string sub -s $i -l 1 -- $arg)
          set -l optdefs (string match -re -- " -(s|-short-option) $opt( |\$)" $progdef)
          set -l optdefs (string match -re -- " -(x|r|a|-(exclusive|require-parameter|arguments))( |\$)" $optdefs)

          if test (count $optdefs) -gt 0
            set arg (string sub -s (math $i + 1) -- "$arg")
            break
          end

          set i (math $i + 1)
        end
      end
  end

  if test -n "$__fish_stripprefix"
    string replace -r -- $__fish_stripprefix '' "$arg"
  else
    printf '%s\n' "$arg"
  end
end

function _example__key_value_list
  set -l sep1 $argv[1]
  set -l sep2 $argv[2]
  set -l value
  set -l keys
  set -l descriptions
  set -l functions
  set -l i

  for i in (command seq 3 3 (count $argv))
    set -a keys $argv[$i]
    set -a descriptions $argv[(math $i + 1)]
    set -a functions $argv[(math $i + 2)]
  end

  set -l comp (_example__get_completing_arg)

  if test -z "$comp" || test (string sub -s -1 -l 1 -- $comp) = $sep1
    for i in (command seq 1 (count $keys))
      if test "$functions[$i]" = false
        printf '%s%s\t%s\n' "$comp" $keys[$i] "$descriptions[$i]"
      else
        printf '%s%s%s\t%s\n' "$comp" $keys[$i] $sep2 "$descriptions[$i]"
      end
    end
    return
  end

  function _example__call_func_for_key -S
    set -l i
    for i in (command seq 1 (count $keys))
      if test $keys[$i] = $argv[1]
        set -g __fish_stripprefix "^.*"(string escape --style=regex -- $sep2)
        $functions[$i]
        set -e __fish_stripprefix
        return
      end
    end
  end

  set -l pair (string split -- $sep1 $comp)[-1]
  set -l split (string split -- $sep2 $pair)

  switch $pair
    case "*$sep2*"
      set -l value_len (string length -- $split[2])

      if test $value_len -gt 0
        set comp (string sub -e -$value_len -- $comp)
      end

      for value in (_example__call_func_for_key $split[1])
        printf '%s%s\n' $comp $value
      end
    case '*'
      set -l key_len (string length -- $split[1])
      set comp (string sub -e -$key_len -- $comp)

      for i in (command seq 1 (count $keys))
        if test "$functions[$i]" = false
          printf '%s%s\t%s\n' "$comp" $keys[$i] "$descriptions[$i]"
        else
          printf '%s%s%s\t%s\n' "$comp" $keys[$i] $sep2 "$descriptions[$i]"
        end
      end
  end
end

function _example__query

  set -l positionals
  set -l positionals_positions
  set -l having_options
  set -l option_values

  set -l options $argv[1]
  set -e argv[1]

  set -l cmd $argv[1]
  set -e argv[1]

  set -l my_cache_key "$(commandline -b) $options"

  if test "$__QUERY_CACHE_KEY" = "$my_cache_key"
    set positionals    $__QUERY_CACHE_POSITIONALS
    set positionals_positions $__QUERY_CACHE_POSITIONALS_POSITIONS
    set having_options $__QUERY_CACHE_HAVING_OPTIONS
    set option_values  $__QUERY_CACHE_OPTION_VALUES
  else

    set -l short_opts_with_arg
    set -l short_opts_without_arg
    set -l short_opts_with_optional_arg
    set -l long_opts_with_arg
    set -l long_opts_without_arg
    set -l long_opts_with_optional_arg

    set -l option

    if test -n "$options"
      for option in (string split -- ',' $options)
        if false
          true
        else if string match -qr -- '^--.+=$' $option
          set -a long_opts_with_arg (string replace -- '=' '' $option)
        else if string match -qr -- '^--.+=\?$' $option
          set -a long_opts_with_optional_arg (string replace -- '=?' '' $option)
        else if string match -qr -- '^--.+$' $option
          set -a long_opts_without_arg $option
        else if string match -qr -- '^-.=$' $option
          set -a short_opts_with_arg (string replace -- '=' '' $option)
        else if string match -qr -- '^-.=\?$' $option
          set -a short_opts_with_optional_arg (string replace -- '=?' '' $option)
        else if string match -qr -- '^-.$' $option
          set -a short_opts_without_arg $option
        end
      end
    end

    set -l cmdline (commandline -poc)
    set -l cmdline_count (count $cmdline)

    set -l argi 2 # cmdline[1] is command name
    while test $argi -le $cmdline_count
      set -l arg "$cmdline[$argi]"
      set -l have_trailing_arg (test $argi -lt $cmdline_count && echo true || echo false)

      switch $arg
        case '-'
          set -a positionals -
          set -s positionals_positions $argi
        case '--'
          set -a positionals $cmdline[$(math $argi + 1)..]
          set -a positionals_positions (command seq (math $argi + 1) $cmdline_count)
          break
        case '--*=*'
          set -l split (string split -m 1 -- '=' $arg)
          set -a having_options $split[1]
          set -a option_values "$split[2]"
        case '--*'
          if contains -- $arg $long_opts_with_arg
            if $have_trailing_arg
              set -a having_options $arg
              set -a option_values $cmdline[(math $argi + 1)]
              set argi (math $argi + 1)
            end
          else
            set -a having_options $arg
            set -a option_values ''
          end
        case '-*'
          set -l end_of_parsing false

          set -l arg_length (string length -- $arg)
          set -l i 2
          while not $end_of_parsing; and test $i -le $arg_length
            set -l option "-$(string sub -s $i -l 1 -- $arg)"
            set -l trailing_chars "$(string sub -s (math $i + 1) -- $arg)"

            if contains -- $option $short_opts_without_arg
              set -a having_options $option
              set -a option_values ''
            else if contains -- $option $short_opts_with_arg
              set end_of_parsing true

              if test -n "$trailing_chars"
                set -a having_options $option
                set -a option_values $trailing_chars
              else if $have_trailing_arg
                set -a having_options $option
                set -a option_values $cmdline[(math $argi + 1)]
                set argi (math $argi + 1)
              end
            else if contains -- $option $short_opts_with_optional_arg
              set end_of_parsing true
              set -a having_options $option
              set -a option_values "$trailing_chars" # may be empty
            end

            set i (math $i + 1)
          end
        case '*'
          set -a positionals $arg
          set -a positionals_positions $argi
      end

      set argi (math $argi + 1)
    end

    set -g __QUERY_CACHE_POSITIONALS    $positionals
    set -g __QUERY_CACHE_POSITIONALS_POSITIONS $positionals_positions
    set -g __QUERY_CACHE_HAVING_OPTIONS $having_options
    set -g __QUERY_CACHE_OPTION_VALUES  $option_values
    set -g __QUERY_CACHE_KEY            $my_cache_key
  end

  switch $cmd
    case 'positional_contains'
      set -l positional_num $argv[1]
      set -e argv[1]
      contains -- $positionals[$positional_num] $argv && return 0 || return 1
    case 'has_option'
      set -l with_incomplete false

      if test $argv[1] = 'WITH_INCOMPLETE'
        set with_incomplete true
        set -e argv[1]
      end

      for option in $having_options
        contains -- $option $argv && return 0
      end

      if $with_incomplete
        set -l tokens (commandline -po)
        set -e tokens[1]
        for option in $argv
          if test 2 -eq (string length -- $option)
            set option (string sub -l 1 -s 2 -- $option)
            string match -q -r -- "^-[A-z0-9]*$option\$"   $tokens[-2] && return 0
            string match -q -r -- "^-[A-z0-9]*$option.*\$" $tokens[-1] && return 0
          else
            string match -q -r -- "^$option\$"       $tokens[-2] && return 0
            string match -q -r -- "^$option(=.*)?\$" $tokens[-1] && return 0
            contains -- $tokens[-1] $argv && return 0
          end
        end
      end

      return 1
    case 'num_of_positionals'
      switch (count $argv)
        case 0
          count $positionals
        case 2
          if contains -- $argv[1] -lt -le -eq -ne -gt -ge;
            test (count $positionals) $argv[1] $argv[2] && return 0 || return 1
          end
      end
    case 'positional_pos'
      echo $positionals_positions[$argv[1]]
  end
end

function _example_start__--preserve-env
  set -n -x
end

function _example_start__-o
  command locale -a
end

function _example_start__-o0
  _example__key_value_list , = \
    lang 'set language' _example_start__-o \
    user 'set user' __fish_complete_users \
    group 'set group' __fish_complete_groups
end

function _example_start__--priority
  printf '%s\t%s\n' \
    low 'Run with lowest priority, background tasks only' \
    normal 'Standard scheduling priority for regular tasks' \
    high 'Higher priority for time-sensitive operations' \
    realtime 'Real-time scheduling, may affect system responsiveness'
end

function _example_start__argument
  set -l opts -v,--verbose,--deprecated-option,--preserve-env=,--priority=,--foreground,--background,--pid-file=,-o=,--options=,-h,--help
  set -l pos (_example__query "$opts" positional_pos 2)
  set -l cmdline (commandline -poc | string escape) (commandline -ct)
  complete -C -- "$cmdline[$pos..]"
end

set -l prog 'example'
set -l query '_example__query'

# Delete existing completions
complete -c $prog -e

# Generally disable file completion
complete -c $prog -x

# command example
set -l opts "-h,--help"
set -l C000 "not $query '$opts' has_option -h --help && not $query '$opts' num_of_positionals -ge 2"
set -l C001 "$query '$opts' num_of_positionals -eq 0"
complete -c $prog -n $C000 -s h -l help -f
complete -c $prog -n $C001 -d Commands -f -a "start\\t'' launch\\t'' view-log\\t''"

# command example start
set -l opts "-v,--verbose,--deprecated-option,--preserve-env=,--priority=,--foreground,--background,--pid-file=,-o=,--options=,-h,--help"
set -l C000 "$query '$opts' positional_contains 1 start launch && not $query '$opts' has_option -h --help && not $query '$opts' num_of_positionals -ge 2"
set -l C001 "$query '$opts' positional_contains 1 start launch && not $query '$opts' has_option -h --help --deprecated-option && $query '$opts' has_option WITH_INCOMPLETE --deprecated-option && not $query '$opts' num_of_positionals -ge 2"
set -l C002 "$query '$opts' positional_contains 1 start launch && not $query '$opts' has_option -h --help --preserve-env && not $query '$opts' num_of_positionals -ge 2"
set -l C003 "$query '$opts' positional_contains 1 start launch && not $query '$opts' has_option -h --help --priority && not $query '$opts' num_of_positionals -ge 2"
set -l C004 "$query '$opts' positional_contains 1 start launch && not $query '$opts' has_option -h --help --background --foreground && not $query '$opts' num_of_positionals -ge 2"
set -l C005 "$query '$opts' positional_contains 1 start launch && not $query '$opts' has_option -h --help --foreground --background && not $query '$opts' num_of_positionals -ge 2"
set -l C006 "$query '$opts' positional_contains 1 start launch && $query '$opts' has_option --background && not $query '$opts' has_option -h --help --pid-file && not $query '$opts' num_of_positionals -ge 2"
set -l C007 "$query '$opts' positional_contains 1 start launch && not $query '$opts' has_option -h --help -o --options && not $query '$opts' num_of_positionals -ge 2"
set -l C008 "$query '$opts' num_of_positionals -eq 1 && $query '$opts' positional_contains 1 start launch"
set -l C009 "$query '$opts' num_of_positionals -ge 2 && $query '$opts' positional_contains 1 start launch"
complete -c $prog -n $C000 -s v -l verbose -f
complete -c $prog -n $C001 -l deprecated-option -f
complete -c $prog -n $C002 -l preserve-env -x -a '(_example__list , _example_start__--preserve-env)'
complete -c $prog -n $C003 -l priority -kx -a '(_example_start__--priority)'
complete -c $prog -n $C004 -l foreground -f
complete -c $prog -n $C005 -l background -f
complete -c $prog -n $C006 -l pid-file -Fr
complete -c $prog -n $C007 -s o -l options -x -a '(_example_start__-o0)'
complete -c $prog -n $C008 -x -a '(__fish_complete_command)'
complete -c $prog -n $C009 -x -a '(_example_start__argument)'

# command example view-log
set -l opts "--pager=?,-h,--help"
set -l C000 "$query '$opts' positional_contains 1 view-log && not $query '$opts' has_option -h --help --pager"
complete -c $prog -n $C000 -l pager -f -a '(__fish_complete_command)'

# vim: ft=fish ts=2 sts=2 sw=2 et