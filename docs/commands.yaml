command: 'none'
category: 'meta'
short: 'No completion, but specifies that an argument is required'
long: |
  Disables autocompletion for this option but still marks it as requiring an argument.
  
  Without specifying `complete`, the option would not take an argument.
definition: |
  prog: "example"
  options:
    - option_strings: ["--none"]
      complete: ["none"]
output: |
  ~ > example --none=<TAB>
  <NO OUTPUT>

---

command: 'combine'
category: 'meta'
short: 'Combine multiple completers'
long: |
  With `combine` multiple completers can be combined into one.

  It takes a list of completers as its argument.
definition: |
  prog: "example"
  options:
    - option_strings: ["--combine"]
      complete: ["combine", [["user"], ["pid"]]]
output: |
  ~ > example --user-list=avahi,daemon,<TAB>
  1439404  3488332  3571716           3607235                 4134206
  alpm     avahi    bin               braph                   daemon
  root     rtkit    systemd-coredump  systemd-journal-remote  systemd-network
  [...]

---

command: 'list'
category: 'meta'
short: 'Complete a comma separated list using a completer'
long: |
  Complete a comma-separted list of any completer.
  
  The separator can be changed by adding `{"separator": ...}`.
  
  By default, duplicate values are not offered for completion. This can be changed by adding `{"duplicates": true}`.
also:
  key_value_list: "For completing a list of key=value pairs"
  file_list: "For completing a list of files"
  directory_list: "For completing a list of directories"
definition: |
  prog: "example"
  options:
    - option_strings: ["--user-list"]
      complete: ["list", ["user"]]
    - option_strings: ["--option-list"]
      complete: ["list", ["choices", ["setuid", "async", "block"]], {"separator": ":"}]
output: |
  ~ > example --user-list=avahi,daemon,<TAB>
  bin                     braph
  colord                  dbus
  dhcpcd                  git

---

command: 'key_value_list'
category: 'meta'
short: 'Complete a comma-separated list of key=value pairs'
long: |
  The first argument is the separator used for delimiting the key-value pairs.

  The second argument is the separator used for delimiting the value from the key.

  The third argument is a dictionary of keys and the completers that should be used.

  If a key does not take an argument, use `null`.

  If a key does take an argument but cannot be completed, use `['none']`.
definition: |
  prog: "example"
  options:
    - option_strings: ["--key-value-list"]
      complete: ["key_value_list", ",", "=", {
        'flag':   null,
        'nocomp': ['none'],
        'user':   ['user'],
        'check'   ['choices', {
          'relaxed': "convert to lowercase before lookup",
          'strict': "no conversion"
        }]
      }]
output: |
  ~ > example --key-value-list flag,user=<TAB>
  bin                     braph
  colord                  dbus
  dhcpcd                  git

---

command: 'integer'
category: 'basic'
short: 'Complete an integer'
notes:
  - "This completer currently serves as documentation and does not provide actual functionality."
also:
  range: "For completing a range of integers"
definition: |
  prog: "example"
  options:
    - option_strings: ["--integer"]
      complete: ["integer"]
output: |
  ~ > example --integer=<TAB>
  <NO OUTPUT>

---

command: 'float'
category: 'basic'
short: 'Complete floating point number'
notes:
  - "This completer currently serves as documentation and does not provide actual functionality."
definition: |
  prog: "example"
  options:
    - option_strings: ["--float"]
      complete: ["float"]
output: |
  ~ > example --float=<TAB>
  <NO OUTPUT>

---

command: 'file'
category: 'basic'
short: 'Complete a file'
long: |
  You can restrict completion to a specific directory by adding `{"directory": ...}`. Directory has to be an absolute path.
   
  You can restrict completion to specific extensions by adding `{"extensions": [...]}`.
   
  You can make matching extensions *fuzzy* by adding `{"fuzzy": true}`.
  Fuzzy means that the files do not have to end with the exact extension. For example `foo.txt.1`.
   
  **NOTE:** Restricting completion to specific file extensions only makes sense if the program being completed actually expects files of those types.
  On Unix-like systems, file extensions generally have no inherent meaning -- they are purely conventional and not required for determining file types.
also:
  file_list: 'For completing a list of files'
  mime_file: "For completing a file based on it's MIME-type"
definition: |
  prog: "example"
  options:
    - option_strings: ["--file"]
      complete: ["file"]
    - option_strings: ["--file-tmp"]
      complete: ["file", {"directory": "/tmp"}]
    - option_strings: ["--file-ext"]
      complete: ["file", {"extensions": ["c", "cpp"]}]
output: |
   ~ > example --file=<TAB>
   dir1/  dir2/  file1  file2
   ~ > example --file-ext=<TAB>
   dir1/  dir2/  file.c  file.cpp

---

command: 'directory'
category: 'basic'
short: 'Complete a directory'
long: |
  You can restrict completion to a specific directory by adding `{"directory": ...}`.
also:
  directory_list: 'For completing a list of directories'
definition: |
  prog: "example"
  options:
    - option_strings: ["--directory"]
      complete: ["directory"]
    - option_strings: ["--directory-tmp"]
      complete: ["directory", {"directory": "/tmp"}]
output: |
   ~ > example --directory=<TAB>
   dir1/  dir2/

---

command: 'file_list'
category: 'basic'
short: 'Complete a comma-separated list of files'
long: |
  This is an alias for `['list', ['file']]`.

  You can restrict completion to a specific directory by adding `{"directory": ...}`.
   
  You can restrict completion to specific extensions by adding `{"extensions": [...]}`.
   
  You can make matching extensions *fuzzy* by adding `{"fuzzy": true}`.
  Fuzzy means that the files do not have to end with the exact extension. For example `foo.txt.1`.
   
  By default, duplicate values are not offered for completion. This can be changed by adding `{"duplicates": true}`.

  The separator can be changed by adding `{"separator": ...}`
definition: |
  prog: "example"
  options:
    - option_strings: ["--file-list"]
      complete: ["file_list"]
output: |
   ~ > example --file-list=file1,file2,<TAB>
   file3  file4

---

command: 'directory_list'
category: 'basic'
short: 'Complete a comma-separated list of directories'
long: |
  This is an alias for `['list', ['directory']]`.

  You can restrict completion to a specific directory by adding `{"directory": ...}`. Directory has to be an absolute path.
   
  The separator can be changed by adding `{"separator": ...}`
   
  By default, duplicate values are not offered for completion. This can be changed by adding `{"duplicates": true}`.
definition: |
  prog: "example"
  options:
    - option_strings: ["--directory-list"]
      complete: ["directory_list"]
output: |
   ~ > example --directory-list=directory1,directory2,<TAB>
   directory3  directory4

---

command: 'mime_file'
category: 'basic'
short: "Complete a file based on it's MIME-type"
long: |
  This completer takes an extended regex passed to `grep -E` to filter the results.
definition: |
  prog: "example"
  options:
    - option_strings: ["--image"]
      complete: ["mime_file", 'image/']
output: |
   ~ > example --image=<TAB>
   dir1/  dir2/  img.png  img.jpg

---

command: 'choices'
category: 'basic'
short: 'Complete from a set of words'
long: |
  Items can be a list or a dictionary.
   
  If a dictionary is supplied, the keys are used as items and the values are used
  as description.
definition: |
  prog: "example"
  options:
    - option_strings: ["--choices-1"]
      complete: ["choices", ["Item 1", "Item 2"]]
    - option_strings: ["--choices-2"]
      complete: ["choices", {"Item 1": "Description 1", "Item 2": "Description 2"}]
output: |
  ~ > example --choices-2=<TAB>
  Item 1  (Description 1)  Item 2  (Description 2)

---

command: 'value_list'
category: 'basic'
short: 'Complete a list of values'
long: |
  Complete one or more items from a list of items. Similar to `mount -o`.
   
  Arguments with assignable values (`mount -o uid=1000`) aren't supported.
   
  Arguments are supplied by adding `{"values": ...}`.
   
  A separator can be supplied by adding `{"separator": ...}` (the default is `","`).
   
  By default, duplicate values are not offered for completion. This can be changed by adding `{"duplicates": true}`.
also:
  key_value_list: "For completing a comma-separated list of key=value pairs"
definition: |
  prog: "example"
  options:
    - option_strings: ["--value-list-1"]
      complete: ["value_list", {"values": ["exec", "noexec"]}]
    - option_strings: ["--value-list-2"]
      complete: ["value_list", {"values": {"one": "Description 1", "two": "Description 2"}}]
output: |
  ~ > example --value-list-1=<TAB>
  exec    noexec
  ~ > example --value-list-1=exec,<TAB>
  noexec
  ~ > example --value-list-2=<TAB>
  one  -- Description 1
  two  -- Description 2

---

command: 'exec'
category: 'custom'
short: 'Complete by the output of a command or function'
long: |
  The output must be in form of:

  ```
  <item_1>\t<description_1>\n
  <item_2>\t<description_2>\n
  [...]
  ```
  
  An item and its description are delimited by a tabulator.
   
  These pairs are delimited by a newline.
also:
  exec_fast: "Faster implementation of exec"
notes:
  - "Functions can be put inside a file and included with `--include-file`"
definition: |
  prog: "example"
  options:
    - option_strings: ["--exec"]
      complete: ["exec", "printf '%s\\t%s\\n' 'Item 1' 'Description 1' 'Item 2' 'Description 2'"]
output: |
  ~ > example --exec=<TAB>
  Item 1  (Description 1)  Item 2  (Description 2)

---

command: 'exec_fast'
category: 'custom'
short: 'Complete by the output of a command or function (fast and unsafe)'
long: |
  Faster version of exec for handling large amounts of data.
   
  This implementation requires that the items of the parsed output do not include
  special shell characters or whitespace.
notes:
  - "Functions can be put inside a file and included with `--include-file`"
definition: |
  prog: "example"
  options:
    - option_strings: ["--exec-fast"]
      complete: ["exec_fast", "printf '%s\\t%s\\n' 1 one 2 two"]
output: |
  ~ > example --exec-internal=<TAB>
  1  -- one
  2  -- one

---

command: 'exec_internal'
category: 'custom'
short: "Complete by a function that uses the shell's internal completion mechanisms"
long: |
  Execute a function that internally modifies the completion state.
  
  This is useful if a more advanced completion is needed.
  
  For **Bash**, it might look like:
  
  ```sh
  my_completion_func() {
      COMPREPLY=( $(compgen -W "read write append" -- "$cur") )
  }
  ```
  
  For **Zsh**, it might look like:
  
  ```sh
  my_completion_func() {
      local items=(
          read:'Read data from a file'
          write:'Write data from a file'
          append:'Append data to a file'
      )
  
      _describe 'my items' items
  }
  ```
  
  For **Fish**, it might look like:
  
  ```sh
  function my_completion_func
      printf '%s\t%s\n' \
          read 'Read data from a file'  \
          write 'Write data from a file' \
          append 'Append data to a file'
  end
  ```
notes:
  - "Functions can be put inside a file and included with `--include-file`"
definition: |
  prog: "example"
  options:
    - option_strings: ["--exec-internal"]
      complete: ["exec_internal", "my_completion_func"]
output: |
  ~ > example --exec-internal=<TAB>
  append  -- Append data to a file
  read    -- Read data from a file
  write   -- Write data from a file

---

command: 'range'
category: 'basic'
short: 'Complete a range of integers'
definition: |
  prog: "example"
  options:
    - option_strings: ["--range-1"]
      complete: ["range", 1, 9]
    - option_strings: ["--range-2"]
      complete: ["range", 1, 9, 2]
output: |
  ~ > example --range-1=<TAB>
  1  2  3  4  5  6  7  8  9
  ~ > example --range-2=<TAB>
  1  3  5  7  9

---

command: 'signal'
category: 'basic'
short: 'Complete signal names'
definition: |
  prog: "example"
  options:
    - option_strings: ["--signal"]
      complete: ["signal"]
output: |
  ~ > example --signal=<TAB>
  ABRT    -- Process abort signal
  ALRM    -- Alarm clock
  BUS     -- Access to an undefined portion of a memory object
  CHLD    -- Child process terminated, stopped, or continued
  CONT    -- Continue executing, if stopped
  FPE     -- Erroneous arithmetic operation
  HUP     -- Hangup
  ILL     -- Illegal instruction
  INT     -- Terminal interrupt signal
  [...]

---

command: 'hostname'
category: 'basic'
short: 'Complete a hostname'
definition: |
  prog: "example"
  options:
    - option_strings: ["--hostname"]
      complete: ["hostname"]
output: |
  ~ > example --hostname=<TAB>
  localhost

---

command: 'process'
category: 'basic'
short: 'Complete a process name'
also:
  pid: 'For completing a PID'
definition: |
  prog: "example"
  options:
    - option_strings: ["--process"]
      complete: ["process"]
output: |
  ~ > example --process=s<TAB>
  scsi_eh_0         scsi_eh_1       scsi_eh_2      scsi_eh_3  scsi_eh_4
  scsi_eh_5         sh              sudo           syndaemon  systemd
  systemd-journald  systemd-logind  systemd-udevd

---

command: 'pid'
category: 'basic'
short: 'Complete a PID'
also:
  process: 'For completing a process name'
definition: |
  prog: "example"
  options:
    - option_strings: ["--pid"]
      complete: ["pid"]
output: |
  ~ > example --pid=<TAB>
  1       13      166     19      254     31      45
  1006    133315  166441  19042   26      32      46
  10150   1392    166442  195962  27      33      4609

---

command: 'filesystem_type'
category: 'basic'
short: 'Complete a filesystem type'
definition: |
  prog: "example"
  options:
    - option_strings: ["--filesystem-type"]
      complete: ["filesystem_type"]
output: |
  ~ > example --filesystem-type=<TAB>
  adfs     autofs   bdev      bfs     binder     binfmt_misc  bpf
  cgroup   cgroup2  configfs  cramfs  debugfs    devpts       devtmpfs

---

command: 'command'
category: 'basic'
short: 'Complete a command'
long: |
  This completer provides completion suggestions for executable commands available in the system's `$PATH`.
   
  `$PATH` can be modified using these options:
   
  `{"path": "<directory>:..."}`: Overrides the default `$PATH` entirely.
   
  `{"path_append": "<directory>:..."}`: Appends to the default `$PATH`.
   
  `{"path_prepend": "<directory>:..."}`: Prepends to the default `$PATH`.
notes:
  - '`path_append` and `path_prepend` can be used together, but both are mutually exclusive with `path`.'
also:
  command_arg: "For completing arguments of a command"
  commandline_string: 'For completing a command line as a string'
definition: |
  prog: "example"
  options:
    - option_strings: ["--command"]
      complete: ["command"]
    - option_strings: ["--command-sbin"]
      complete: ["command", {"path_append": "/sbin:/usr/sbin"}]
output: |
  ~ > example --command=bas<TAB>
  base32    base64    basename  basenc    bash      bashbug

---

command: 'command_arg'
category: 'basic'
short: 'Complete arguments of a command'
notes:
  - 'This completer can only be used in combination with a previously defined `command` completer.'
  - 'This completer requires `repeatable: true`.'
also:
  command: 'For completing a command'
  commandline_string: 'For completing a command line as a string'
definition: |
  prog: "example"
  positionals:
    - number: 1
      complete: ["command"]

    - number: 2
      complete: ["command_arg"]
      repeatable: true
output: |
  ~ > example sudo bas<TAB>
  base32    base64    basename  basenc    bash      bashbug

---

command: 'commandline_string'
category: 'basic'
short: 'Complete a command line as a string'
definition: |
  prog: "example"
  options:
    - option_strings: ["--commandline"]
      complete: ["commandline_string"]
output: |
  ~ > example --commandline='sudo ba<TAB>
  base32    base64    basename  basenc    bash      bashbug

---

command: 'user'
category: 'basic'
short: 'Complete a username'
also:
  uid: 'For completing a user id'
definition: |
  prog: "example"
  options:
    - option_strings: ["--user"]
      complete: ["user"]
output: |
  ~ > example --user=<TAB>
  avahi                   bin                     braph
  colord                  daemon                  dbus
  dhcpcd                  ftp                     git
  [...]

---

command: 'group'
category: 'basic'
short: 'Complete a group'
also:
  gid: 'For completing a group id'
definition: |
  prog: "example"
  options:
    - option_strings: ["--group"]
      complete: ["group"]
output: |
  ~ > example --group=<TAB>
  adm                     audio                   avahi
  bin                     braph                   colord
  daemon                  dbus                    dhcpcd
  disk                    floppy                  ftp
  games                   git                     groups
  [...]

---

command: 'uid'
category: 'basic'
short: 'Complete a user id'
also:
  user: 'For completing a user name'
definition: |
  prog: "example"
  options:
    - option_strings: ["--uid"]
      complete: ["uid"]
output: |
  ~ > example --uid=<TAB>
  0      -- root
  1000   -- braph
  102    -- polkitd
  133    -- rtkit
  14     -- ftp
  1      -- bin
  2      -- daemon
  33     -- http
  65534  -- nobody
  [...]

---

command: 'gid'
category: 'basic'
short: 'Complete a group id'
also:
  group: 'For completing a group name'
definition: |
  prog: "example"
  options:
    - option_strings: ["--gid"]
      complete: ["gid"]
output: |
  ~ > example --gid=<TAB>
  0      -- root
  1000   -- braph
  102    -- polkitd
  108    -- vboxusers
  11     -- ftp
  12     -- mail
  133    -- rtkit
  19     -- log
  [...]

---

command: 'service'
category: 'basic'
short: 'Complete a SystemD service'
definition: |
  prog: "example"
  options:
    - option_strings: ["--service"]
      complete: ["service"]
output: |
  ~ > example --service=<TAB>
  TODO
  [...]

---

command: 'variable'
category: 'basic'
short: 'Complete a shell variable name'
also:
  environment: 'For completing an environment variable'
definition: |
  prog: "example"
  options:
    - option_strings: ["--variable"]
      complete: ["variable"]
output: |
  ~ > example --variable=HO<TAB>
  HOME      HOSTNAME  HOSTTYPE

---

command: 'environment'
category: 'basic'
short: 'Complete a shell environment variable name'
definition: |
  prog: "example"
  options:
    - option_strings: ["--environment"]
      complete: ["environment"]
output: |
  ~ > example --environment=X<TAB>
  XDG_RUNTIME_DIR  XDG_SEAT  XDG_SESSION_CLASS  XDG_SESSION_ID
  XDG_SESSION_TYPE XDG_VTNR

---

command: 'history'
category: 'basic'
short: "Complete based on a shell's history"
long: |
  The argument is an extended regular expression passed to `grep -E`.
definition: |
  prog: "example"
  options:
    - option_strings: ["--history"]
      complete: ["history", '[a-zA-Z0-9]+@[a-zA-Z0-9]+']
output: |
  ~ > example --history=<TAB>
  foo@bar mymail@myprovider

---

command: 'date'
category: 'basic'
short: 'Complete a date string'
long: |
  The argument is the date format as described in `strftime(3)`.
also:
  date_format: "For completing a date format string"
implemented: ['Zsh']
definition: |
  prog: "example"
  options:
    - option_strings: ["--date"]
      complete: ["date", '%Y-%m-%d']
output: |
  ~ > example --date=<TAB>
  
           November                        
  Mo  Tu  We  Th  Fr  Sa  Su     
       1   2   3   4   5   6    
   7   8   9  10  11  12  13
  14  15  16  17  18  19  20
  21  22  23  24  25  26  27
  28  29  30                 

---

command: 'date_format'
category: 'basic'
short: 'Complete a date format string'
also:
  date: "For completing a date"
implemented: ['Fish', 'Zsh']
definition: |
  prog: "example"
  options:
    - option_strings: ["--date-format"]
      complete: ["date_format"]
output: |
  ~ > example --date-format '%<TAB>
  a     -- abbreviated day name
  A     -- full day name
  B     -- full month name
  c     -- preferred locale date and time
  C     -- 2-digit century
  d     -- day of month (01-31)
  D     -- American format month/day/year (%m/%d/%y)
  e     -- day of month ( 1-31)
  [...]

---

command: 'net_interface'
category: 'bonus'
short: 'Complete a network interface'
definition: |
  prog: "example"
  options:
    - option_strings: ["--net-interface"]
      complete: ["net_interface"]
output: |
  ~ > example --net-interface=<TAB>
  eno1  enp1s0  lo  wlo1  wlp2s0
  [...]

---

command: 'mountpoint'
category: 'bonus'
short: 'Complete a mountpoint'
definition: |
  prog: "example"
  options:
    - option_strings: ["--mountpoint"]
      complete: ["mountpoint"]
output: |
  ~ > example --mountpoint=<TAB>
  /  /boot  /home  /proc  /run  /sys  /tmp
  [...]

---

command: 'login_shell'
category: 'bonus'
short: 'Complete a login shell'
definition: |
  prog: "example"
  options:
    - option_strings: ["--login-shell"]
      complete: ["login_shell"]
output: |
  ~ > example --login-shell=<TAB>
  /bin/bash   /bin/sh         /usr/bin/fish       /usr/bin/sh
  [...]

---

command: 'charset'
category: 'bonus'
short: 'Complete a charset'
definition: |
  prog: "example"
  options:
    - option_strings: ["--charset"]
      complete: ["charset"]
output: |
  ~ > example --charset=A<TAB>
  ANSI_X3.110-1983  ANSI_X3.4-1968    ARMSCII-8         ASMO_449

---

command: 'locale'
category: 'bonus'
short: 'Complete a locale'
definition: |
  prog: "example"
  options:
    - option_strings: ["--locale"]
      complete: ["locale"]
output: |
  ~ > example --locale=<TAB>
  C  C.UTF-8  de_DE  de_DE@euro  de_DE.iso88591  de_DE.iso885915@euro
  de_DE.UTF-8  deutsch  en_US  en_US.iso88591  en_US.UTF-8  german  POSIX

---

command: 'timezone'
category: 'bonus'
short: 'Complete a timezone'
definition: |
  prog: "example"
  options:
    - option_strings: ["--timezone"]
      complete: ["timezone"]
output: |
  ~ > example --timezone=Europe/B<TAB>
  Belfast     Belgrade    Berlin      Bratislava
  Brussels    Bucharest   Budapest    Busingen

---

command: 'alsa_card'
category: 'bonus'
short: 'Complete an ALSA card'
also:
  alsa_device: "For completing an ALSA device"
definition: |
  prog: "example"
  options:
    - option_strings: ["--also-card"]
      complete: ["alsa_card"]
output: |
  ~ > example --alsa-card=<TAB>
  0  1

---

command: 'alsa_device'
category: 'bonus'
short: 'Complete an ALSA device'
also:
  alsa_card: "For completing an ALSA card"
definition: |
  prog: "example"
  options:
    - option_strings: ["--also-device"]
      complete: ["alsa_device"]
output: |
  ~ > example --alsa-device=<TAB>
  hw:0  hw:1
